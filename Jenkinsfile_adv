pipeline {
  agent { label 'master' }

  options { ansiColor('xterm') }

  parameters {
    choice(
      name: 'DEVICE',
      choices: ['UPP','NewGen'],
      description: '''Select which project you want to run.

Each project corresponds to a specific hardware and firmware setup:
• UPP – Used for Gen2 power platform flashing and validation.
• NewGen – Used for Dynamic 6 generation devices.

Choose the project that matches your target device for flashing and testing'''
    )
    string(
      name: 'FLASH_LOOPS',
      defaultValue: '1',
      trim: true,
      description: '''How many flash cycles to run.
Enter a positive integer. Non-numeric/empty values default to 1.'''
    )
    booleanParam(
      name: 'DO_FLASH',
      defaultValue: true,
      description: 'Run the flashing steps. Uncheck to only prepare files and print summary.'
    )
     booleanParam(
      name: 'DO_UDS',
      defaultValue: true,
      description: 'Run UDS client step after flashing.'
    )
  }

  environment {
    LANG = 'en_US.UTF-8'
    LC_ALL = 'en_US.UTF-8'
    RCLONE_BASE      = 'irp:General/releases'
    DEST_FOLDER      = "${env.HOME}/workspace/NewVersion"
    REMOTE_TARGET    = 'C:\\Jenkins\\NewVersion'
    WORKSPACE_TARGET = "C:/Jenkins/workspace"
    REMOTE_USER      = 'dyno'
    REQUIREMENTS     = 'requirements.txt'
  }

  stages {

    stage('Environment') {
      steps {
        script {
          switch (params.DEVICE) {
            case 'UPP':
              env.REMOTE_IP    = '192.168.10.31'
              env.REMOTE_USER  = 'dyno'
              env.MAIN_VER_DIR = 'HD_Gen2/upp'
              env.REQUIREMENTS = 'requirements.txt'
              break
            case 'NewGen':
              env.REMOTE_IP    = '192.168.10.85'
              env.REMOTE_USER  = 'dyno'
              env.MAIN_VER_DIR = 'dynamic 6/newGen'
              env.REQUIREMENTS = 'requirements.txt'
              break
            default:
              error "DEVICE not set or unrecognized. Set DEVICE to 'UPP' or 'NewGen'."
          }
          echo "Using remote ${env.REMOTE_USER}@${env.REMOTE_IP}, firmware dir: ${env.MAIN_VER_DIR}"
        }
      }
    }

    stage('Clone Project on Remote Windows') {
      steps {
        sh """
          echo " Running remote clone + setup (PowerShell via stdin)..."
          ssh ${REMOTE_USER}@${REMOTE_IP} powershell -NoProfile -Command - <<'PS'
if (-not (Test-Path 'C:\\Jenkins\\workspace')) {
  New-Item -ItemType Directory -Path 'C:\\Jenkins\\workspace' -Force | Out-Null
}

if (-not (Test-Path 'C:\\Jenkins\\workspace\\Auto_UDS')) {
  git clone https://github.com/IRPSystems/Auto_UDS.git 'C:\\Jenkins\\workspace\\Auto_UDS'
} else {
  Set-Location 'C:\\Jenkins\\workspace\\Auto_UDS'
  git pull
}

Set-Location 'C:\\Jenkins\\workspace\\Auto_UDS'

# Create venv (consistent name)
if (Test-Path '.venv') { Remove-Item -Recurse -Force '.venv' }
python -m venv .venv
# & '.venv\\Scripts\\pip.exe' install -r 'requirements.txt'
PS
        """
      }
    }

    stage('Find Latest Firmware Folder') {
    when { expression { return params.DO_FLASH } }
    }
      steps {
        script {
          def latestFolder = sh(
            script: """
              rclone lsd "${RCLONE_BASE}/${MAIN_VER_DIR}" | sort -k2,3 | tail -n1 | awk '{\$1=\$2=\$3=\$4=""; print \$0}' | sed 's/^ *//'
            """,
            returnStdout: true
          ).trim()

          def previousFolder = sh(
            script: """
              rclone lsd "${RCLONE_BASE}/${MAIN_VER_DIR}" | sort -k2,3 | tail -n2 | head -n1 | awk '{\$1=\$2=\$3=\$4=""; print \$0}' | sed 's/^ *//'
            """,
            returnStdout: true
          ).trim()

          if (!latestFolder) {
            error "[FAIL] Could not find the latest folder in ${RCLONE_BASE}/${MAIN_VER_DIR}"
          }
          if (!previousFolder) {
            error "[FAIL] Could not find the previous folder in ${RCLONE_BASE}/${MAIN_VER_DIR} (need at least two releases)"
          }

          echo " [OK] Latest firmware folder: ${latestFolder}"
          env.LATEST_FOLDER = latestFolder
          echo " [OK] Previous firmware folder: ${previousFolder}"
          env.PREVIOUS_FOLDER = previousFolder
        }
      }
    }

    stage('Copy Previous/Latest Firmware') {
    when { expression { return params.DO_FLASH } }
    }
      steps {
        sh """
          echo " Cleaning destination folder: ${DEST_FOLDER}"
          rm -rf "${DEST_FOLDER}"
          mkdir -p "${DEST_FOLDER}"

          echo " Copying from: ${RCLONE_BASE}/${MAIN_VER_DIR}/${LATEST_FOLDER}/"
          rclone copy "${RCLONE_BASE}/${MAIN_VER_DIR}/${LATEST_FOLDER}/" "${DEST_FOLDER}/${LATEST_FOLDER}"

          echo " Copying from: ${RCLONE_BASE}/${MAIN_VER_DIR}/${PREVIOUS_FOLDER}/"
          rclone copy "${RCLONE_BASE}/${MAIN_VER_DIR}/${PREVIOUS_FOLDER}/" "${DEST_FOLDER}/${PREVIOUS_FOLDER}"
        """

        sh """
          echo " Deleting and recreating remote NewVersion folder on ${REMOTE_USER}@${REMOTE_IP}..."
          ssh ${REMOTE_USER}@${REMOTE_IP} powershell -NoProfile -Command - <<'PS'
\$root = 'C:\\Jenkins\\NewVersion'
Write-Host " Target:" \$root

# Ensure parent exists
\$parent = Split-Path -Parent \$root
if (-not (Test-Path \$parent)) { New-Item -ItemType Directory -Path \$parent -Force | Out-Null }

# Create root if missing
if (-not (Test-Path \$root)) { New-Item -ItemType Directory -Path \$root -Force | Out-Null }

# Mirror an EMPTY temp folder to root (reliably empties deep trees)
\$temp = Join-Path \$env:TEMP ([guid]::NewGuid().ToString())
New-Item -ItemType Directory -Path \$temp -Force | Out-Null
robocopy \$temp \$root /MIR /NFL /NDL /NJH /NJS /NP | Out-Null
\$rc = \$LASTEXITCODE
Remove-Item -Recurse -Force \$temp -ErrorAction SilentlyContinue

# Fallback if robocopy indicates failure (>7)
if (\$rc -gt 7) {
  Write-Host "Robocopy exit code \$rc; attempting PowerShell fallback..."
  Get-ChildItem -LiteralPath \$root -Force | Remove-Item -Recurse -Force -ErrorAction Continue
}

# (Re)create the root
if (-not (Test-Path \$root)) { New-Item -ItemType Directory -Path \$root -Force | Out-Null }

# Verify empty; fail if not
\$items = Get-ChildItem -LiteralPath \$root -Force
if (\$items.Count -gt 0) {
  Write-Host '[FAIL] Folder not empty after cleanup:'
  \$items | Select-Object Name,Mode,Length | Format-Table -AutoSize
  exit 1
} else {
  Write-Host ' [OK] Folder is empty.'
}
PS
        """

        sh """
          echo " Sending files to remote host"
          scp -r "${DEST_FOLDER}/${LATEST_FOLDER}"   ${REMOTE_USER}@${REMOTE_IP}:"C:/Jenkins/NewVersion"
          scp -r "${DEST_FOLDER}/${PREVIOUS_FOLDER}" ${REMOTE_USER}@${REMOTE_IP}:"C:/Jenkins/NewVersion"
          ssh ${REMOTE_USER}@${REMOTE_IP} "cmd /c dir C:\\Jenkins\\NewVersion"
          echo " Firmware files copied successfully to: ${REMOTE_TARGET} on ${REMOTE_IP}"
        """
      }
    }

    stage('Flash Loops') {
      when { expression { return params.DO_FLASH } }
      steps {
        script {
          // normalize FLASH_LOOPS
          def raw = (params.FLASH_LOOPS ?: '1').toString().trim()
          def n = (raw ==~ /^[0-9]+$/) ? raw.toInteger() : 1
          if (n < 1) n = 1
          def MAX_LOOPS = 1000
          if (n > MAX_LOOPS) { echo "FLASH_LOOPS (${n}) exceeds safety ceiling (${MAX_LOOPS}); clamping."; n = MAX_LOOPS }
          echo "Normalized FLASH_LOOPS: ${n}"
          env.FLASH_LOOPS_NORM = n.toString()

          for (int i = 1; i <= n; i++) {
            echo "Starting flash round ${i} of ${n}"
            sh """
              ssh ${REMOTE_USER}@${REMOTE_IP} powershell -NoProfile -Command - <<'PS'
# UTF-8 everything (prevents charmap issues)
chcp 65001 | Out-Null
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
${'$'}env:PYTHONIOENCODING = 'utf-8'
${'$'}env:PYTHONUTF8 = '1'
${'$'}env:ROUND_INDEX = '${i}/${n}'

# Inject Jenkins values as literal strings (Groovy already expanded them)
${'$'}prevFolder   = "${env.PREVIOUS_FOLDER}"
${'$'}latestFolder = "${env.LATEST_FOLDER}"
if ([string]::IsNullOrWhiteSpace(${ '$'}prevFolder) -or [string]::IsNullOrWhiteSpace(${ '$'}latestFolder)) {
  Write-Host "[FAIL] PREVIOUS_FOLDER or LATEST_FOLDER is empty. Aborting."
  exit 1
}
${'$'}oldPath = "C:\\Jenkins\\NewVersion\\${'$'}prevFolder"
${'$'}newPath = "C:\\Jenkins\\NewVersion\\${'$'}latestFolder"
Write-Host " Using --old=${'$'}oldPath --new=${'$'}newPath"

Set-Location 'C:\\Jenkins\\workspace\\Auto_UDS'
${'$'}flashPath = 'C:\\Jenkins\\workspace\\Auto_UDS\\1UPP_flash.py'
if (-Not (Test-Path ${'$'}flashPath)) {
  Write-Host "[FAIL]  Flash script not found at ${'$'}flashPath"
  exit 1
}

Write-Host " Running UPP_flash.py (round ${i}/${n}) ..."
& 'C:\\Jenkins\\workspace\\Auto_UDS\\.venv\\Scripts\\python.exe' -X utf8 -u ${'$'}flashPath `
  --old "${'$'}oldPath" `
  --new "${'$'}newPath"

if (${ '$'}LASTEXITCODE -ne 0) {
  Write-Host "[FAIL] Flash script failed with exit code ${'$'}LASTEXITCODE (round ${i}/${n})"
  exit ${'$'}LASTEXITCODE
} else {
  Write-Host "[OK] Flash script completed successfully (round ${i}/${n})"
}
PS
            """
          }
        }
      }
    }

    stage('UDS') {
      when { expression { return params.DO_UDS } }
      steps {
        script {
    sh """
              ssh ${REMOTE_USER}@${REMOTE_IP} powershell -NoProfile -Command - <<'PS'
            # UTF-8 everything (prevents charmap issues)
            chcp 65001 | Out-Null
            [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
            ${'$'}env:PYTHONIOENCODING = 'utf-8'
            ${'$'}env:PYTHONUTF8 = '1'
            ${'$'}env:ROUND_INDEX = '${i}/${n}'

            Set-Location 'C:\\Jenkins\\workspace\\Auto_UDS'
            ${'$'}flashPath = 'C:\\Jenkins\\workspace\\Auto_UDS\\update_copy_and_run_upp.py'

        }
        }
        }
    stage('Flash Summary') {
      steps {
        script {
          echo '----------------------------------------'
          echo 'Collecting version details and generating summary...'
          echo '----------------------------------------'

          def result = sh(
            script: """
              ssh ${REMOTE_USER}@${REMOTE_IP} powershell -NoLogo -NoProfile -NonInteractive -Command - <<'PS'
${'$'}ErrorActionPreference = 'Stop'
${'$'}ProgressPreference    = 'SilentlyContinue'

${'$'}root   = 'C:\\Jenkins\\NewVersion'
${'$'}prev   = '${env.PREVIOUS_FOLDER}'
${'$'}latest = '${env.LATEST_FOLDER}'

function Get-HexPair([string]${'$'}dirPath) {
  ${'$'}merged = Join-Path ${'$'}dirPath 'FW Merged'
  if (-not (Test-Path -LiteralPath ${'$'}merged)) { return '|' }  # app|boot

  ${'$'}app  = Get-ChildItem -LiteralPath ${'$'}merged -Filter '*Merge_App_*UPP_v*.hex'  -ErrorAction SilentlyContinue |
               Sort-Object LastWriteTime | Select-Object -Last 1
  ${'$'}boot = Get-ChildItem -LiteralPath ${'$'}merged -Filter '*Merge_Boot_*UPP_v*.hex' -ErrorAction SilentlyContinue |
               Sort-Object LastWriteTime | Select-Object -Last 1

  ${'$'}appName  = if (${'$'}app)  { ${'$'}app.Name }  else { '' }
  ${'$'}bootName = if (${'$'}boot) { ${'$'}boot.Name } else { '' }
  Write-Output "${'$'}appName|${'$'}bootName"
}

${'$'}prevPair   = Get-HexPair (Join-Path ${'$'}root ${'$'}prev)
${'$'}latestPair = Get-HexPair (Join-Path ${'$'}root ${'$'}latest)
Write-Output "${'$'}prevPair|${'$'}latestPair"
PS
            """,
            returnStdout: true
          ).trim()

          def parts = result.split('\\|', -1)
          if (parts.size() < 4) {
            error "Could not parse flash metadata. Got: ${result}"
          }

          def prevApp  = parts[0] ?: 'N/A'
          def prevBoot = parts[1] ?: 'N/A'
          def newApp   = parts[2] ?: 'N/A'
          def newBoot  = parts[3] ?: 'N/A'

          // reuse normalized loops if set, else compute quickly
          def loops = env.FLASH_LOOPS_NORM ?: ((params.FLASH_LOOPS ?: '1').isInteger() ? params.FLASH_LOOPS : '1')
          def now   = sh(script: "date -u +'%Y-%m-%d %H:%M:%S UTC'", returnStdout: true).trim()

          def summary = """
----------------------------------------
FLASH SUMMARY REPORT
----------------------------------------
Device: ${params.DEVICE}
Total loops flashed: ${params.DO_FLASH ? loops : '0 (flash skipped)'}
Timestamp: ${now}

Previous version folder: ${env.PREVIOUS_FOLDER}
  App : ${prevApp}
  Boot: ${prevBoot}

New version folder: ${env.LATEST_FOLDER}
  App : ${newApp}
  Boot: ${newBoot}
----------------------------------------
""".stripIndent()

          echo summary
        }
      }
    }
  }
}
